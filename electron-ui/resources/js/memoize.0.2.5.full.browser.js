// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

window.memoize = (function (modules) {
	var resolve, getRequire, require, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]};
	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullpath, state) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split('/');
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
			} else {
				tree.push(scope);
				scope = scope[dir];
			}
			if (!scope) throw notFoundError(fullpath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullpath, 1);
			}
			return resolve(scope, tree, 'index', fullpath, 2);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullpath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports };
		fn.call(exports, exports, module, getRequire(scope, tree));
		return module.exports;
	};
	require = function (scope, tree, fullpath) {
		var name, path = fullpath, t = fullpath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) throw notFoundError(fullpath);
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullpath, state);
	};
	getRequire = function (scope, tree) {
		return function (path) { return require(scope, [].concat(tree), path); };
	};
	return getRequire(modules, []);
})({
	"es5-ext": {
		":mainpath:": "lib",
		"lib": {
			"Array": {
				"from.js": function (exports, module, require) {
					'use strict';

					var isArguments   = require('../Function/is-arguments')

					  , isArray = Array.isArray, slice = Array.prototype.slice;

					module.exports = function (obj) {
						if (isArray(obj)) {
							return obj;
						} else if (isArguments(obj)) {
							return (obj.length === 1) ? [obj[0]] : Array.apply(null, obj);
						} else {
							return slice.call(obj);
						}
					};
				},
				"prototype": {
					"e-index-of.js": function (exports, module, require) {
						'use strict';

						var numIsNaN = require('../../Number/is-nan')
						  , ois      = require('../../Object/is')
						  , value    = require('../../Object/valid-value')

						  , indexOf = Array.prototype.indexOf;

						module.exports = function (searchElement/*, fromIndex*/) {
							var i;
							if (!numIsNaN(searchElement) && (searchElement !== 0)) {
								return indexOf.apply(this, arguments);
							}

							for (i = (arguments[1] >>> 0); i < (value(this).length >>> 0); ++i) {
								if (this.hasOwnProperty(i) && ois(searchElement, this[i])) {
									return i;
								}
							}
							return -1;
						};
					},
					"last-index.js": function (exports, module, require) {
						'use strict';

						var value = require('../../Object/valid-value');

						module.exports = function () {
							var i, l;
							if (!(l = (value(this).length >>> 0))) {
								return null;
							}
							i = l - 1;
							while (!this.hasOwnProperty(i)) {
								if (--i === -1) {
									return null;
								}
							}
							return i;
						};
					},
					"last.js": function (exports, module, require) {
						'use strict';

						var lastIndex = require('./last-index');

						module.exports = function () {
							var i;
							if ((i = lastIndex.call(this)) !== null) {
								return this[i];
							}
							return undefined;
						};
					}
				}
			},
			"Error": {
				"custom.js": function (exports, module, require) {
					'use strict';

					var d      = require('../Object/descriptor')
					  , extend = require('../Object/extend')

					  , captureStackTrace = Error.captureStackTrace
					  , CustomError;

					CustomError = module.exports = function CustomError(message, code/*, ext*/) {
						var ext = arguments[2];
						if (ext != null) extend(this, ext);
						this.message = String(message);
						if (code != null) this.code = String(code);
						if (captureStackTrace) captureStackTrace(this, CustomError);
					};

					CustomError.prototype = Object.create(Error.prototype, {
						constructor: d(CustomError),
						name: d('CustomError')
					});
				}
			},
			"Function": {
				"is-arguments.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call((function () { return arguments; }()));

					module.exports = function (x) {
						return toString.call(x) === id;
					};
				}
			},
			"Number": {
				"is-nan.js": function (exports, module, require) {
					'use strict';

					module.exports = function (value) {
						return (value !== value); //jslint: skip
					};
				},
				"is-number.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call(1);

					module.exports = function (x) {
						return ((typeof x === 'number') ||
							((x instanceof Number) ||
								((typeof x === 'object') && (toString.call(x) === id))));
					};
				}
			},
			"Object": {
				"_iterate.js": function (exports, module, require) {
					// Internal method, used by iteration functions.
					// Calls a function for each key-value pair found in object
					// Optionally takes compareFn to iterate object in specific order

					'use strict';

					var isCallable = require('./is-callable')
					  , callable   = require('./valid-callable')
					  , value      = require('./valid-value')

					  , call = Function.prototype.call, keys = Object.keys;

					module.exports = function (method) {
						return function (obj, cb/*, thisArg, compareFn*/) {
							var list, thisArg = arguments[2], compareFn = arguments[3];
							obj = Object(value(obj));
							callable(cb);

							list = keys(obj);
							if (compareFn) {
								list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
							}
							return list[method](function (key, index) {
								return call.call(cb, thisArg, obj[key], key, obj, index);
							});
						};
					};
				},
				"copy.js": function (exports, module, require) {
					'use strict';

					var isPlainObject = require('./is-plain-object')
					  , forEach       = require('./for-each')
					  , extend        = require('./extend')
					  , value         = require('./valid-value')

					  , recursive;

					recursive = function (to, from, cloned) {
						forEach(from, function (value, key) {
							var index;
							if (isPlainObject(value)) {
								if ((index = cloned[0].indexOf(value)) === -1) {
									cloned[0].push(value);
									cloned[1].push(to[key] = extend({}, value));
									recursive(to[key], value, cloned);
								} else {
									to[key] = cloned[1][index];
								}
							}
						}, from);
					};

					module.exports = function (obj/*, deep*/) {
						var copy;
						if ((copy = Object(value(obj))) === obj) {
							copy = extend({}, obj);
							if (arguments[1]) {
								recursive(copy, obj, [[obj], [copy]]);
							}
						}
						return copy;
					};
				},
				"descriptor.js": function (exports, module, require) {
					'use strict';

					var isCallable = require('./is-callable')
					  , callable   = require('./valid-callable')
					  , validValue = require('./valid-value')
					  , copy       = require('./copy')
					  , map        = require('./map')
					  , isString   = require('../String/is-string')
					  , contains   = require('../String/prototype/contains')

					  , bind = Function.prototype.bind
					  , defineProperty = Object.defineProperty
					  , d;

					d = module.exports = function (dscr, value) {
						var c, e, w;
						if (arguments.length < 2) {
							value = dscr;
							dscr = null;
						}
						if (dscr == null) {
							c = w = true;
							e = false;
						} else {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
							w = contains.call(dscr, 'w');
						}

						return { value: value, configurable: c, enumerable: e, writable: w };
					};

					d.gs = function (dscr, get, set) {
						var c, e;
						if (isCallable(dscr)) {
							set = (get == null) ? undefined : callable(get);
							get = dscr;
							dscr = null;
						} else {
							get = (get == null) ? undefined : callable(get);
							set = (set == null) ? undefined : callable(set);
						}
						if (dscr == null) {
							c = true;
							e = false;
						} else {
							c = contains.call(dscr, 'c');
							e = contains.call(dscr, 'e');
						}

						return { get: get, set: set, configurable: c, enumerable: e };
					};

					d.binder = function self(name, dv) {
						var value, dgs;
						if (!isString(name)) {
							return map(name, function (dv, name) { return self(name, dv); });
						}
						value = validValue(dv) && callable(dv.value);
						dgs = copy(dv);
						delete dgs.writable;
						delete dgs.value;
						dgs.get = function () {
							dv.value = bind.call(value, this);
							defineProperty(this, name, dv);
							return this[name];
						};
						return dgs;
					};
				},
				"extend.js": function (exports, module, require) {
					'use strict';

					var value = require('./valid-value')

					  , forEach = Array.prototype.forEach, slice = Array.prototype.slice
					  , keys = Object.keys

					  , extend;

					extend = function (src) {
						keys(Object(src)).forEach(function (key) {
							this[key] = src[key];
						}, this);
					};

					module.exports = function (dest/*, â€¦src*/) {
						forEach.call(arguments, value);
						slice.call(arguments, 1).forEach(extend, dest);
						return dest;
					};
				},
				"for-each.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./_iterate')('forEach');
				},
				"is-callable.js": function (exports, module, require) {
					// Inspired by: http://www.davidflanagan.com/2009/08/typeof-isfuncti.html

					'use strict';

					var forEach = Array.prototype.forEach.bind([]);

					module.exports = function (obj) {
						var type;
						if (!obj) {
							return false;
						}
						type = typeof obj;
						if (type === 'function') {
							return true;
						}
						if (type !== 'object') {
							return false;
						}

						try {
							forEach(obj);
							return true;
						} catch (e) {
							if (e instanceof TypeError) {
								return false;
							}
							throw e;
						}
					};
				},
				"is-empty.js": function (exports, module, require) {
					'use strict';

					var value = require('./valid-value');

					module.exports = function (obj) {
						var i;
						value(obj);
						for (i in obj) { //jslint: skip
							if (obj.propertyIsEnumerable(i)) return false;
						}
						return true;
					};
				},
				"is-plain-object.js": function (exports, module, require) {
					'use strict';

					var getPrototypeOf = Object.getPrototypeOf, prototype = Object.prototype
					  , toString = prototype.toString

					  , id = {}.toString();

					module.exports = function (value) {
						var proto;
						if (!value || (typeof value !== 'object') || (toString.call(value) !== id)) {
							return false;
						}
						proto = getPrototypeOf(value);
						return (proto === prototype) || (getPrototypeOf(proto) === null);
					};
				},
				"is.js": function (exports, module, require) {
					// Implementation credits go to:
					// http://wiki.ecmascript.org/doku.php?id=harmony:egal

					'use strict';

					module.exports = function (x, y) {
						return (x === y) ?
								((x !== 0) || ((1 / x) === (1 / y))) :
								((x !== x) && (y !== y)); //jslint: skip
					};
				},
				"map.js": function (exports, module, require) {
					'use strict';

					var callable = require('./valid-callable')
					  , forEach  = require('./for-each')

					  , call = Function.prototype.call;

					module.exports = function (obj, cb/*, thisArg*/) {
						var o = {}, thisArg = arguments[2];
						callable(cb);
						forEach(obj, function (value, key, obj, index) {
							o[key] = call.call(cb, thisArg, value, key, obj, index);
						});
						return o;
					};
				},
				"valid-callable.js": function (exports, module, require) {
					'use strict';

					var isCallable = require('./is-callable');

					module.exports = function (fn) {
						if (!isCallable(fn)) {
							throw new TypeError(fn + " is not a function");
						}
						return fn;
					};
				},
				"valid-value.js": function (exports, module, require) {
					'use strict';

					module.exports = function (value) {
						if (value == null) {
							throw new TypeError("Cannot use null or undefined");
						}
						return value;
					};
				}
			},
			"String": {
				"is-string.js": function (exports, module, require) {
					'use strict';

					var toString = Object.prototype.toString

					  , id = toString.call('');

					module.exports = function (x) {
						return (typeof x === 'string') || (x && (typeof x === 'object') &&
							((x instanceof String) || (toString.call(x) === id))) || false;
					};
				},
				"prototype": {
					"contains.js": function (exports, module, require) {
						'use strict';

						var indexOf = String.prototype.indexOf;

						module.exports = function (searchString/*, position*/) {
							return indexOf.call(this, searchString, arguments[1]) > -1;
						};
					}
				}
			},
			"global.js": function (exports, module, require) {
				'use strict';

				module.exports = new Function("return this")();
			}
		}
	},
	"event-emitter": {
		":mainpath:": "lib",
		"lib": {
			"_id.js": function (exports, module, require) {
				'use strict';

				module.exports = '_ee2_';
			},
			"core.js": function (exports, module, require) {
				'use strict';

				var d        = require('es5-ext/lib/Object/descriptor')
				  , callable = require('es5-ext/lib/Object/valid-callable')
				  , id       = require('./_id')

				  , apply = Function.prototype.apply, call = Function.prototype.call
				  , create = Object.create, defineProperty = Object.defineProperty
				  , defineProperties = Object.defineProperties
				  , descriptor = { configurable: true, enumerable: false, writable: true }

				  , on, once, off, emit
				  , colId, methods, descriptors, base;

				colId = id + 'l_';

				on = function (type, listener) {
					var data;

					callable(listener);

					if (!this.hasOwnProperty(id)) {
						data = descriptor.value = {};
						defineProperty(this, id, descriptor);
						descriptor.value = null;
					} else {
						data = this[id];
					}
					if (!data.hasOwnProperty(type)) data[type] = listener;
					else if (data[type].hasOwnProperty(colId)) data[type].push(listener);
					else (data[type] = [data[type], listener])[colId] = true;

					return this;
				};

				once = function (type, listener) {
					var once, self;

					callable(listener);
					self = this;
					on.call(this, type, once = function () {
						off.call(self, type, once);
						apply.call(listener, this, arguments);
					});

					once._listener = listener;
					return this;
				};

				off = function (type, listener) {
					var data, listeners, candidate, i;

					callable(listener);

					if (!this.hasOwnProperty(id)) return this;
					data = this[id];
					if (!data.hasOwnProperty(type)) return this;
					listeners = data[type];

					if (listeners.hasOwnProperty(colId)) {
						for (i = 0; (candidate = listeners[i]); ++i) {
							if ((candidate === listener) || (candidate._listener === listener)) {
								if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
								else listeners.splice(i, 1);
							}
						}
					} else {
						if ((listeners === listener) || (listeners._listener === listener)) {
							delete data[type];
						}
					}

					return this;
				};

				emit = function (type) {
					var data, i, l, listener, listeners, args;

					if (!this.hasOwnProperty(id)) return;
					data = this[id];
					if (!data.hasOwnProperty(type)) return;
					listeners = data[type];

					if (listeners.hasOwnProperty(colId)) {
						l = arguments.length;
						args = new Array(l - 1);
						for (i = 1; i < l; ++i) {
							args[i - 1] = arguments[i];
						}

						listeners = listeners.slice();
						for (i = 0; (listener = listeners[i]); ++i) {
							apply.call(listener, this, args);
						}
					} else {
						switch (arguments.length) {
						case 1:
							call.call(listeners, this);
							break;
						case 2:
							call.call(listeners, this, arguments[1]);
							break;
						case 3:
							call.call(listeners, this, arguments[1], arguments[2]);
							break;
						default:
							l = arguments.length;
							args = new Array(l - 1);
							for (i = 1; i < l; ++i) {
								args[i - 1] = arguments[i];
							}
							apply.call(listeners, this, args);
						}
					}
				};

				methods = {
					on: on,
					once: once,
					off: off,
					emit: emit
				};

				descriptors = {
					on: d(on),
					once: d(once),
					off: d(off),
					emit: d(emit)
				};

				base = defineProperties({}, descriptors);

				module.exports = exports = function (o) {
					return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
				};
				exports.methods = methods;
			},
			"has-listeners.js": function (exports, module, require) {
				'use strict';

				var isEmpty = require('es5-ext/lib/Object/is-empty')
				  , value   = require('es5-ext/lib/Object/valid-value')
				  , id      = require('./_id');

				module.exports = function (obj/*, type*/) {
					var type;
					value(obj);
					type = arguments[1];
					if (arguments.length > 1) {
						return obj.hasOwnProperty(id) && obj[id].hasOwnProperty(type);
					} else {
						return obj.hasOwnProperty(id) && !isEmpty(obj[id]);
					}
				};
			}
		}
	},
	"memoizee": {
		"lib": {
			"_base.js": function (exports, module, require) {
				// To be used internally, memoize factory

				'use strict';

				var callable = require('es5-ext/lib/Object/valid-callable')
				  , forEach  = require('es5-ext/lib/Object/for-each')
				  , ee       = require('event-emitter/lib/core')

				  , ext;

				module.exports = exports = function (core) {
					return function self(fn/*, options */) {
						var options, length, get, clear, conf;

						callable(fn);
						if (fn.memoized) {
							// Do not memoize already memoized function
							return fn;
						}

						options = Object(arguments[1]);
						conf = ee({ memoize: self, fn: fn });

						// Normalize length
						if (isNaN(options.length)) {
							length = fn.length;
							// Special case
							if (options.async && ext.async) {
								--length;
							}
						} else {
							length = (options.length === false) ? false : (options.length >>> 0);
						}

						core(conf, length);

						forEach(ext, function (fn, name) {
							if (fn.force) {
								fn(conf, options);
							} else if (options[name]) {
								fn(options[name], conf, options);
							}
						});

						fn = conf.fn;
						get = conf.get;
						clear = conf.clear;

						conf.memoized.clear = function () { clear(get(arguments)); };
						conf.memoized.clearAll = function () {
							conf.emit('purgeall');
							conf.clearAll();
						};
						conf.memoized.memoized = true;
						conf.emit('ready');
						return conf.memoized;
					};
				};
				ext = exports.ext = {};
			},
			"ext": {
				"async.js": function (exports, module, require) {
					// Support for asynchronous functions

					'use strict';

					var toArray    = require('es5-ext/lib/Array/from')
					  , last       = require('es5-ext/lib/Array/prototype/last')
					  , forEach    = require('es5-ext/lib/Object/for-each')
					  , isCallable = require('es5-ext/lib/Object/is-callable')
					  , nextTick   = require('next-tick')

					  , isArray = Array.isArray, slice = Array.prototype.slice
					  , apply = Function.prototype.apply;

					require('../_base').ext.async = function (ignore, conf) {
						var cache, purge;

						cache = conf.async = {};

						(function (org) {
							var value, cb, initContext, initArgs, fn, resolver;

							conf.on('init', function (id) {
								value.id = id;
								cache[id] = cb ? [cb] : [];
							});

							conf.on('hit', function (id, syncArgs, syncCtx) {
								if (!cb) {
									return;
								}

								if (isArray(cache[id])) {
									cache[id].push(cb);
								} else {
									nextTick(function (cb, id, ctx, args) {
										if (cache[id]) {
											conf.emit('hitasync', id, syncArgs, syncCtx);
											apply.call(cb, this.context, this);
										} else {
											// Purged in a meantime, we shouldn't rely on cached value, recall
											fn.apply(ctx, args);
										}
									}.bind(cache[id], cb, id, initContext, initArgs));
									initContext = initArgs = null;
								}
							});
							conf.fn = function () {
								var args, asyncArgs;
								args = arguments;
								asyncArgs = toArray(args);
								asyncArgs.push(value = function self(err) {
									var i, cb, waiting, res;
									if (self.id == null) {
										// Shouldn't happen, means async callback was called sync way
										nextTick(apply.bind(self, this, arguments));
										return;
									}
									waiting = cache[self.id];
									if (conf.cache.hasOwnProperty(self.id)) {
										if (err) {
											delete cache[self.id];
											conf.clear(self.id);
										} else {
											arguments.context = this;
											cache[self.id] = arguments;
											conf.emit('initasync', self.id, waiting.length);
										}
									} else {
										delete cache[self.id];
									}
									for (i = 0; (cb = waiting[i]); ++i) {
										res = apply.call(cb, this, arguments);
									}
									return res;
								});
								return apply.call(org, this, asyncArgs);
							};

							fn = conf.memoized;
							resolver = function (args) {
								cb = last.call(args);
								if (isCallable(cb)) {
									return slice.call(args, 0, -1);
								} else {
									cb = null;
									return args;
								}
							};
							conf.memoized = function () {
								return fn.apply(initContext = this, initArgs = resolver(arguments));
							};
							forEach(fn, function (value, name) {
								conf.memoized[name] = function () {
									return fn[name].apply(this, resolver(arguments));
								};
							});

						}(conf.fn));

						conf.on('purge', purge = function (id) {
							// If false, we don't have value yet, so we assume that intention is not
							// to memoize this call. After value is obtained we don't cache it but
							// gracefully pass to callback
							if (!isArray(cache[id])) {
								conf.emit('purgeasync', id);
								delete cache[id];
							}
						});

						conf.on('purgeall', function () {
							forEach(conf.async, function (value, id) { purge(id); });
						});
					};
				},
				"dispose.js": function (exports, module, require) {
					// Call dispose callback on each cache purge

					'use strict';

					var callable = require('es5-ext/lib/Object/valid-callable')
					  , forEach  = require('es5-ext/lib/Object/for-each')
					  , ext      = require('../_base').ext

					  , slice = Array.prototype.slice;

					ext.dispose = function (dispose, conf, options) {
						var clear, async;

						callable(dispose);

						async = (options.async && ext.async);
						conf.on('purge' + (async ? 'async' : ''), clear =  async ? function (id) {
							var value = conf.async[id];
							delete conf.cache[id];
							dispose.apply(conf.memoized['_memoize:context_'], slice.call(value, 1));
						} : function (id) {
							var value = conf.cache[id];
							delete conf.cache[id];
							dispose.call(conf.memoized['_memoize:context_'], value);
						});

						if (!async) {
							conf.on('purgeall', function () {
								forEach(conf.cache, function (value, id) { clear(id); });
							});
						}
					};
				},
				"max-age.js": function (exports, module, require) {
					// Timeout cached values

					'use strict';

					var isNumber = require('es5-ext/lib/Number/is-number')
					  , forEach  = require('es5-ext/lib/Object/for-each')
					  , nextTick = require('next-tick')
					  , ext      = require('../_base').ext

					  , max = Math.max, min = Math.min;

					ext.maxAge = function (maxAge, conf, options) {
						var cache, async, preFetchAge, preFetchCache;

						maxAge = maxAge >>> 0;
						if (!maxAge) {
							return;
						}

						cache = {};
						async = options.async && ext.async;
						conf.on('init' + (async ? 'async' : ''), function (id) {
							cache[id] = setTimeout(function () { conf.clear(id); }, maxAge);
							if (preFetchCache) {
								preFetchCache[id] = setTimeout(function () { delete preFetchCache[id]; },
									preFetchAge);
							}
						});
						conf.on('purge' + (async ? 'async' : ''), function (id) {
							clearTimeout(cache[id]);
							if (preFetchCache && preFetchCache[id]) {
								clearTimeout(preFetchCache[id]);
								delete preFetchCache[id];
							}
							delete cache[id];
						});

						if (options.preFetch) {
							if (isNumber(options.preFetch)) {
								preFetchAge = max(min(Number(options.preFetch), 1), 0);
							} else {
								preFetchAge = 0.333;
							}
							if (preFetchAge) {
								preFetchCache = {};
								preFetchAge = (1 - preFetchAge) * maxAge;
								conf.on('hit' + (async ? 'async' : ''), function (id, args, ctx) {
									if (!preFetchCache[id]) {
										preFetchCache[id] = true;
										nextTick(function () {
											if (preFetchCache[id] === true) {
												delete preFetchCache[id];
												conf.clear(id);
												conf.memoized.apply(ctx, args);
											}
										});
									}
								});
							}
						}

						if (!async) {
							conf.on('purgeall', function () {
								forEach(cache, function (id) {
									clearTimeout(id);
								});
								cache = {};
								if (preFetchCache) {
									forEach(preFetchCache, function (id) {
										clearTimeout(id);
									});
									preFetchCache = {};
								}
							});
						}
					};
				},
				"max.js": function (exports, module, require) {
					// Limit cache size, LRU (least recently used) algorithm.

					'use strict';

					var ext = require('../_base').ext;

					ext.max = function (max, conf, options) {
						var index, base, size, queue, map, async;

						max = max >>> 0;
						if (!max) {
							return;
						}

						index = -1;
						base = size = 0;
						queue = {};
						map = {};
						async = options.async && ext.async;

						conf.on('init' + (async ? 'async' : ''), function (id) {
							queue[++index] = id;
							map[id] = index;
							++size;
							if (size > max) {
								conf.clear(queue[base]);
							}
						});

						conf.on('hit' + (async ? 'async' : ''), function (id) {
							var oldIndex = map[id];
							queue[++index] = id;
							map[id] = index;
							delete queue[oldIndex];
							if (base === oldIndex) {
								while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
							}
						});

						conf.on('purge' + (async ? 'async' : ''), function (id) {
							var oldIndex = map[id];
							delete queue[oldIndex];
							--size;
							if (base === oldIndex) {
								if (!size) {
									index = -1;
									base = 0;
								} else {
									while (!queue.hasOwnProperty(++base)) continue; //jslint: skip
								}
							}
						});

						if (!async) {
							conf.on('purgeall', function () {
								index = -1;
								base = size = 0;
								queue = {};
								map = {};
							});
						}
					};
				},
				"method.js": function (exports, module, require) {
					// Memoized methods factory

					'use strict';

					var d        = require('es5-ext/lib/Object/descriptor')
					  , global   = require('es5-ext/lib/global')
					  , extend   = require('es5-ext/lib/Object/extend')
					  , isString = require('es5-ext/lib/String/is-string')

					  , create = Object.create, defineProperty = Object.defineProperty;

					require('../_base').ext.method = function (method, conf, options) {
						if (isString(options.method)) {
							method = { name: String(options.method),
								descriptor: { configurable: true, writable: true } };
						} else {
							method = options.method;
							method.name = String(method.name);
							method.descriptor = (method.descriptor == null) ?
									{ configurable: true, writable: true } : Object(method.descriptor);
						}
						options = create(options);
						options.method = undefined;

						(function (fn) {
							conf.memoized = function () {
								var memoized;
								if (this && (this !== global)) {
									memoized = method.descriptor.value =
										conf.memoize(conf.fn.bind(this), options);
									defineProperty(this, method.name, method.descriptor);
									defineProperty(memoized, '_memoize:context_', d(this));
									return memoized.apply(this, arguments);
								}
								return fn.apply(this, arguments);
							};
							extend(conf.memoized, fn);
						}(conf.memoized));
					};
				},
				"ref-counter.js": function (exports, module, require) {
					// Reference counter, useful for garbage collector like functionality

					'use strict';

					var ext = require('../_base').ext;

					ext.refCounter = function (ignore, conf, options) {
						var cache, async;

						cache = {};
						async = options.async && ext.async;

						conf.on('init' + (async ? 'async' : ''), async ? function (id, length) {
							cache[id] = length;
						} : function (id) { cache[id] = 1; });
						conf.on('hit' + (async ? 'async' : ''), function (id) { ++cache[id]; });
						conf.on('purge' + (async ? 'async' : ''), function (id) {
							delete cache[id];
						});
						if (!async) {
							conf.on('purgeall', function () { cache = {}; });
						}

						conf.memoized.clearRef = function () {
							var id = conf.get(arguments);
							if (cache.hasOwnProperty(id)) {
								if (!--cache[id]) {
									conf.clear(id);
									return true;
								}
								return false;
							}
							return null;
						};
					};
				},
				"resolvers.js": function (exports, module, require) {
					// Normalize arguments before passing them to underlying function

					'use strict';

					var toArray    = require('es5-ext/lib/Array/from')
					  , forEach    = require('es5-ext/lib/Object/for-each')
					  , callable   = require('es5-ext/lib/Object/valid-callable')

					  , slice = Array.prototype.slice

					  , resolve;

					resolve = function (args) {
						return this.map(function (r, i) {
							return r ? r(args[i]) : args[i];
						}).concat(slice.call(args, this.length));
					};

					require('../_base').ext.resolvers = function (resolvers, conf) {
						var resolver;

						resolver = toArray(resolvers);
						resolver.forEach(function (r) { (r == null) || callable(r); });
						resolver = resolve.bind(resolver);

						(function (fn) {
							conf.memoized = function () {
								var value;
								conf.memoized.args = arguments;
								value = fn.apply(this, resolver(arguments));
								delete conf.memoized.args;
								return value;
							};
							forEach(fn, function (value, name) {
								conf.memoized[name] = function () {
									return fn[name].apply(this, resolver(arguments));
								};
							});
						}(conf.memoized));
					};
				}
			},
			"index.js": function (exports, module, require) {
				// Provides memoize with all options

				'use strict';

				var regular   = require('./regular')
				  , primitive = require('./primitive')

				  , call = Function.prototype.call;

				// Order is significant!
				require('./ext/dispose');
				require('./ext/resolvers');
				require('./ext/async');
				require('./ext/ref-counter');
				require('./ext/method');
				require('./ext/max-age');
				require('./ext/max');

				module.exports = function (fn/* options */) {
					var options = Object(arguments[1]);
					return call.call(options.primitive ? primitive : regular, this, fn, options);
				};
			},
			"primitive.js": function (exports, module, require) {
				// Memoize working in primitive mode

				'use strict';

				var CustomError  = require('es5-ext/lib/Error/custom')
				  , hasListeners = require('event-emitter/lib/has-listeners')

				  , getId0 = function () { return ''; }
				  , getId1 = function (args) { return args[0]; }

				  , apply = Function.prototype.apply, call = Function.prototype.call;

				module.exports = require('./_base')(function (conf, length) {
					var get, cache = conf.cache = {}, fn
					  , hitListeners, initListeners, purgeListeners;

					if (length === 1) {
						get = conf.get = getId1;
					} else if (length === false) {
						get = conf.get = function (args) {
							var id = '', i, length = args.length;
							if (length) {
								id += args[i = 0];
								while (--length) {
									id += '\u0001' + args[++i];
								}
							} else {
								id = '\u0002';
							}
							return id;
						};
					} else if (length) {
						get = conf.get = function (args) {
							var id = String(args[0]), i = 0, l = length;
							while (--l) { id += '\u0001' + args[++i]; }
							return id;
						};
					} else {
						get = conf.get = getId0;
					}

					conf.memoized = (length === 1) ? function (id) {
						var value;
						if (cache.hasOwnProperty(id)) {
							hitListeners && conf.emit('hit', id, arguments, this);
							return cache[id];
						} else {
							if (arguments.length === 1) {
								value = call.call(fn, this, id);
							} else {
								value = apply.call(fn, this, arguments);
							}
							if (cache.hasOwnProperty(id)) {
								throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
							}
							cache[id] = value;
							initListeners && conf.emit('init', id);
							return value;
						}
					} : function () {
						var id = get(arguments), value;
						if (cache.hasOwnProperty(id)) {
							hitListeners && conf.emit('hit', id, arguments, this);
							return cache[id];
						} else {
							value = apply.call(conf.fn, this, arguments);
							if (cache.hasOwnProperty(id)) {
								throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
							}
							cache[id] = value;
							initListeners && conf.emit('init', id);
							return value;
						}
					};

					conf.clear = function (id) {
						if (cache.hasOwnProperty(id)) {
							purgeListeners && conf.emit('purge', id);
							delete cache[id];
						}
					};
					conf.clearAll = function () { cache = conf.cache = {}; };

					conf.once('ready', function () {
						fn = conf.fn;
						hitListeners = hasListeners(conf, 'hit');
						initListeners = hasListeners(conf, 'init');
						purgeListeners = hasListeners(conf, 'purge');
					});
				});
			},
			"regular.js": function (exports, module, require) {
				// Memoize working in object mode (supports any type of arguments)

				'use strict';

				var CustomError  = require('es5-ext/lib/Error/custom')
				  , indexOf      = require('es5-ext/lib/Array/prototype/e-index-of')
				  , hasListeners = require('event-emitter/lib/has-listeners')

				  , apply = Function.prototype.apply;

				// Results are saved internally within array matrix:
				// [0] -> Result of calling function with no arguments
				// [1] -> Matrix that keeps results when function is called with one argument
				//        [1][0] -> Array of arguments with which
				//                 function have been called
				//        [1][1] -> Array of results that matches [1][0] array
				// [2] -> Matrix that keeps results when function is called with two arguments
				//        [2][0] -> Array of first (of two) arguments with which
				//                function have been called
				//        [2][1] -> Matrixes that keeps results for two arguments function calls
				//                  Each matrix matches first argument found in [2][0]
				//                  [2][1][x][0] -> Array of second arguments with which
				//                                  function have been called.
				//                  [2][1][x][1] -> Array of results that matches [2][1][x][0]
				//                                   arguments array
				// ...and so on
				module.exports = require('./_base')(function (conf, length) {
					var map, map1, map2, get, set, clear, count, fn
					  , hitListeners, initListeners, purgeListeners
					  , cache = conf.cache = {}, argsCache;

					if (length === 0) {
						map = null;
						get = conf.get = function () { return map; };
						set = function () { return ((map = 1)); };
						clear = function () { map = null; };
						conf.clearAll = function () {
							map = null;
							cache = conf.cache = {};
						};
					} else {
						count = 0;
						if (length === 1) {
							map1 = [];
							map2 = [];
							get = conf.get = function (args) {
								var index = indexOf.call(map1, args[0]);
								return (index === -1) ? null : map2[index];
							};
							set = function (args) {
								map1.push(args[0]);
								map2.push(++count);
								return count;
							};
							clear = function (id) {
								var index = indexOf.call(map2, id);
								if (index !== -1) {
									map1.splice(index, 1);
									map2.splice(index, 1);
								}
							};
							conf.clearAll = function () {
								map1 = [];
								map2 = [];
								cache = conf.cache = {};
							};
						} else if (length === false) {
							map = [];
							argsCache = {};
							get = conf.get = function (args) {
								var index = 0, set = map, i, length = args.length;
								if (length === 0) {
									return set[length] || null;
								} else if ((set = set[length])) {
									while (index < (length - 1)) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) return null;
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) return null;
									return set[1][i] || null;
								}
								return null;
							};
							set = function (args) {
								var index = 0, set = map, i, length = args.length;
								if (length === 0) {
									set[length] = ++count;
								} else {
									if (!set[length]) {
										set[length] = [[], []];
									}
									set = set[length];
									while (index < (length - 1)) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) {
											i = set[0].push(args[index]) - 1;
											set[1].push([[], []]);
										}
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										i = set[0].push(args[index]) - 1;
									}
									set[1][i] = ++count;
								}
								argsCache[count] = args;
								return count;
							};
							clear = function (id) {
								var index = 0, set = map, i, args = argsCache[id], length = args.length
								  , path = [];
								if (length === 0) {
									delete set[length];
								} else if ((set = set[length])) {
									while (index < (length - 1)) {
										i = indexOf.call(set[0], args[index]);
										if (i === -1) {
											return;
										}
										path.push(set, i);
										set = set[1][i];
										++index;
									}
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										return;
									}
									id = set[1][i];
									set[0].splice(i, 1);
									set[1].splice(i, 1);
									while (!set[0].length && path.length) {
										i = path.pop();
										set = path.pop();
										set[0].splice(i, 1);
										set[1].splice(i, 1);
									}
								}
								delete argsCache[id];
							};
							conf.clearAll = function () {
								map = [];
								cache = conf.cache = {};
								argsCache = {};
							};
						} else {
							map = [[], []];
							argsCache = {};
							get = conf.get = function (args) {
								var index = 0, set = map, i;
								while (index < (length - 1)) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) return null;
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) return null;
								return set[1][i] || null;
							};
							set = function (args) {
								var index = 0, set = map, i;
								while (index < (length - 1)) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										i = set[0].push(args[index]) - 1;
										set[1].push([[], []]);
									}
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) {
									i = set[0].push(args[index]) - 1;
								}
								set[1][i] = ++count;
								argsCache[count] = args;
								return count;
							};
							clear = function (id) {
								var index = 0, set = map, i, path = [], args = argsCache[id];
								while (index < (length - 1)) {
									i = indexOf.call(set[0], args[index]);
									if (i === -1) {
										return;
									}
									path.push(set, i);
									set = set[1][i];
									++index;
								}
								i = indexOf.call(set[0], args[index]);
								if (i === -1) {
									return;
								}
								id = set[1][i];
								set[0].splice(i, 1);
								set[1].splice(i, 1);
								while (!set[0].length && path.length) {
									i = path.pop();
									set = path.pop();
									set[0].splice(i, 1);
									set[1].splice(i, 1);
								}
								delete argsCache[id];
							};
							conf.clearAll = function () {
								map = [[], []];
								cache = conf.cache = {};
								argsCache = {};
							};
						}
					}
					conf.memoized = function () {
						var id = get(arguments), value;
						if (id != null) {
							hitListeners && conf.emit('hit', id, arguments, this);
							return cache[id];
						} else {
							value = apply.call(fn, this, arguments);
							id = get(arguments);
							if (id != null) {
								throw new CustomError("Circular invocation", 'CIRCULAR_INVOCATION');
							}
							id = set(arguments);
							cache[id] = value;
							initListeners && conf.emit('init', id);
							return value;
						}
					};
					conf.clear = function (id) {
						if (cache.hasOwnProperty(id)) {
							purgeListeners && conf.emit('purge', id);
							clear(id);
							delete cache[id];
						}
					};

					conf.once('ready', function () {
						fn = conf.fn;
						hitListeners = hasListeners(conf, 'hit');
						initListeners = hasListeners(conf, 'init');
						purgeListeners = hasListeners(conf, 'purge');
					});
				});
			}
		}
	},
	"next-tick": {
		":mainpath:": "lib/next-tick",
		"lib": {
			"next-tick.js": function (exports, module, require) {
				'use strict';

				if ((typeof process !== 'undefined') && process &&
						(typeof process.nextTick === 'function')) {

					// Node.js
					module.exports = process.nextTick;

				} else if (typeof setImmediate === 'function') {

					// W3C Draft
					// https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
					module.exports = function (cb) { setImmediate(cb); };

				} else {

					// Wide available standard
					module.exports = function (cb) { setTimeout(cb, 0); };
				}
			}
		}
	}
})("memoizee/lib/index");
